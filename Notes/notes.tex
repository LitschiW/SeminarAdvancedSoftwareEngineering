\documentclass{article}

\usepackage[numbers,round]{natbib}
\bibliographystyle{abbrvnat}

\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage{amsmath}
\usepackage{hyperref}


\begin{document}	
	\tableofcontents 
	\newpage
	 \section{Gerneral Notes}
	 \begin{itemize}
	 	\item	Measurement Bias is hard to control \cite{PredictingPerformanceAutmatedFeatureDetectionSiegmund2012}
	 	\item PUMA Tool
	 	\item Palladio
	 	\item PLeTsPerf
	 \end{itemize}
	
	\section{Automated Feature Detection}
	\subsection{Formeln\cite{PredictingPerformanceAutmatedFeatureDetectionSiegmund2012}}
	
Operatoren
\begin{align*}
\text{Komposition/Konfiguration} &:  a \cdot b\\
\text{Interaction} &: a\#b\\
\text{Feature Interaction} &: a\times b = a\#b \cdot a \cdot b\\
\Pi(a)  &= \text{Performance von a, wenn a eine Konfiguration ist} 
\end{align*}
Performance
\begin{align*}
	\Pi(a \cdot b) &= \Pi(a) \cdot \Pi(b)\\
	\Pi(a\#b) &= \Pi(a \times b) - (\Pi(a) + \Pi(b))\\
	\Rightarrow \Pi(a \times b) &=  \Pi(a\#b) + (\Pi(a) + \Pi(b))
\end{align*}
	Es existieren $\mathcal{O}(n^2)$ viele Konfigurationsmöglichkeiten $\Rightarrow$ zusammenfassen in Konfigurationen $C$.
\begin{align*}
\text{Impact  of Feature $a$ on $C$: } \Delta a_C &= \Pi(a \times C) - \Pi(C)\\
&= \Pi(a\#C) + \Pi(a)
\end{align*}
Beachte: $C$ kann Konfiguration aus $i$ Features sein $\Rightarrow \mathcal{O}(i^2)$ Additionen. Schlecht!\\ 
	Deswegen messen versuchen wir eine minimale Konfiguration  $min(a)$  zu finden, die $a$ \textbf{nicht} enthält aber mit $a$ legitim erweiterbar ist.\\
	Für jedes Feature $a$ gilt:
	\begin{equation*}
	\Delta a_{min} = \Pi(a \times min(a)) - \Pi(min(a))
	\end{equation*}
	Da das Ergebnis nur für die minimale Konfiguration gilt ist es nicht akkurat.
	Vorhersagen könne über das Messen eines interaction deltas verbessert werden.
	Seien $a$ und $b \in C$, dann gilt: 
	\begin{equation*}
	\begin{split}
	\Delta (a\#b)_C &= \Pi(a\#b \times C ) - \Pi(C)\\
					&= \Pi(a\#b\#C ) + \Pi(a\#b) + \Pi(c)  - \Pi(C)\\
					&= \Pi(a\#b\#C ) + \Pi(a\#b)
	\end{split}
	\end{equation*}
	
	Jetzt können wir halbwegs verlässlich und mit reduziertem Aufwand den Performance Einfluss von einzelnen Features in einer bestimmten Konfiguration bestimmen. Es bleibt aber immer noch das Problem mit der Größe.\\
	Um den Suchraum zu reduzieren stufen wir jedes Feature als interaktiv oder nicht interaktiv ein. 
		\begin{equation*}
		 a \text{ interacts } \Leftrightarrow \exists C,D | C \neq D \land \Delta a_C \neq \Delta a_D
		\end{equation*}
	Dafür benötigen wir je 4 Messungen: $\Pi(a \times min(a))$ , $\Pi(min(a))$ , $\Pi(a \times max(a))$ , $\Pi(max(a))$. Mit diesen kann man $\Delta a_{min}$ und $\Delta a_{max}$ bestimmen.
	Und für $C=min(a)$ und $D = max(a)$ für $\forall a$ bestimmen ob sie interaktiv sind oder nicht.
	Allerdings wissen wir nicht, welche Features mit welchen interagieren. $\mathcal{O}(n!) \text{ Kombinationen}\Rightarrow$ Suche wird durch Heuristiken geleitet: \\
	\begin{enumerate}
		\item Pair-Wise Interaction $(\mathcal{O}\left(\begin{smallmatrix}
		2\\
		n
		\end{smallmatrix}\right))$
		\item Higher Order Interactions (three way interactions, mostly based on Pair wise founds)
		\item Hot-Spot Features additional measurements to find hotspot features.
	\end{enumerate}
	Diese Heuristiken werden auf Implication chain angewendet um nach interaktiven paaren zu suchen. (s. Dokument)
	
	 
	\section{Comparative Analysis of Software Performance Prediction Approaches in Context of Component-based System \cite{ComparativeanalysisAbdelaziz112011}}
	
	\nocite{*}
	\bibliography{../template}
	
\end{document}