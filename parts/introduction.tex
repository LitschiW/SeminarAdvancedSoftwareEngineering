\section{Introduction} \label{sec:introduction}
Todays programs are mostly highly configurable. Whilst buying or downloading a program a user already decides on which version of program (s)he wants to have. On Installation there are mostly multiple options reaching from 'Language' to a selection of software features. Once a program is installed there are usually multiple startup, customization and configuration options provided for a customer. But having such a large amount of options brings some problems into the development of modern applications. This paper will manly focus on the problem of learning and predicting the performance of a highly configurable software system.
A developer needs some sort of mechanism to ensure his application has the required performance under most or all configurations. On one hand this is important when it comes to contract terms and conditions with customers. A program should perform as good as the customer requires it to \cite{VariabilityAwarePerformancePredictionJianmeiSigmundApel}. Otherwise a developer may face fines. On the other hand performance prediction is helpful in finding performance problems or room for improvement. This either helps with the previous point of reaching a set performance target or to make the program more user friendly (less response time, smaller binary size, ...) and therefore more attractive \cite{SoftwareEngineeringMenschenProzesseTechniken}.

First all a stable development strategy is needed. Preferably it can offer the creation of multiple similar products with little redundant code or components whilst providing methods to optimize thier performance. In practice software product lines (SPL) are used for this case. This paper will first have a short look at the importance of SPLs in performance engineering.

Furthermore there is the problem of performance prediction. Why do we need to learn and predict the performance of a system?
The amount of possible configurations naturally lies in $\mathcal{O}(2^n)$. This scaling makes it hard to test each singular configuration for its performance or correctness. Especially if the configuration under test is unpredictably chosen by a user \cite{PredictingPerformanceAutmatedFeatureDetectionSiegmund2012} or if feature-interactions impair the performance \cite{VariabilityAwarePerformancePredictionJianmeiSigmundApel}. For example:
Berkley DB (C) is a database management program for embedded systems. It has 18 features and 2560 different configurations. In their paper \inlineQuote{{\textit{Predicting Performance via Automated Feature-Interaction Detection}}} \citet{AutomatedFeatureDetectionSiegmund2012} measured each of the possible configurations and it took them 426h (=17,75d)\footnote{These measurements were done on computers that are (from today's point of view) fairly slow \cite{AutomatedFeatureDetectionSiegmund2012,CPUDatabase}.}. This and other examples from the same paper show, that it is not practical to brute-force measure each and every configuration possible. \\ 
Consequently when one wants to efficiently analysing a software product (line), its performance can only be partially measured and behaviour beyond that has to be predicted. Over time a lot of methods in different disciplines have been prosed.\\
This paper aims to give a short introduction into the importance of software product lines (SPL) in regards to performance engineering and an overview over solutions for predicting and learning the performance of a highly configurable software system.
\TODOX{mention references}